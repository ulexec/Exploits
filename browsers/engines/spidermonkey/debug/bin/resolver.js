
function ELF64_R_SYM(i) {
	return ((i) >> 32);
}

function ELF64_R_TYPE(i) {
	return ((i) & 0xffffffff);
}

let offsetof_e_phnum = 56n;
let offsetof_e_phoff = 32n;
let offsetof_p_type = 0n;
let offsetof_p_flags = 4n;
let offsetof_p_filesz = 32n;
let offsetof_p_offset = 8n;
let offsetof_p_vaddr = 16n;
let offsetof_d_tag = 0n;
let offsetof_d_un_d_val = 8n;
let offsetof_r_offset = 0n;
let offsetof_r_info = 8n;
let offsetof_st_name = 0n;

let sizeof_Elf64_Phdr = 56n;
let sizeof_Elf64_Dyn = 16n;
let sizeof_Elf64_Rela = 24n;
let sizeof_Elf64_Sym = 24n;

let PT_LOAD = 1n;
let PT_DYNAMIC = 2n;

let PF_W = 2n;
let PF_X = 1n;

let DT_PLTGOT = 3n;
let DT_JMPREL = 23n;
let DT_PLTRELSZ = 2n;
let DT_SYMTAB = 6n;
let DT_STRTAB = 5n;
let DT_STRSZ = 10n;
let DT_RELAENT = 9n;
let DT_PLTREL = 20n;
let DT_RELA = 7n;
let DT_RELASZ = 8n;
let R_X86_64_JUMP_SLOT = 7n;
let R_X86_64_GLOB_DAT = 6n;

function arb_rstring(addr) {
	var str = "";

	while (1) {
		ch = arb_r1(addr);
		if (ch == 0)
			return str;
		str += String.fromCharCode(ch);
		addr += 1n;
	}
}

function arb_r1(addr) {
	v0 = arb_read(addr);
	return Number(v0[0]);
}

function arb_r2(addr) {
	v0 = arb_read(addr);
	pointer = BigInt(v0[0]) + (BigInt(v0[1]) << 8n);
	return pointer;
}

function arb_r4(addr) {
	v0 = arb_read(addr);
	pointer = BigInt(v0[0]) + (BigInt(v0[1]) << 8n) + (BigInt(v0[2]) << 16n) + (BigInt(v0[3]) << 24n);
	return pointer;
}

function arb_r8(addr) {
	v0 = arb_read(addr);
	pointer = BigInt(v0[0]) + (BigInt(v0[1]) << 8n) + (BigInt(v0[2]) << 16n) + (BigInt(v0[3]) << 24n) + (BigInt(v0[4]) << 32n) + (BigInt(v0[5]) << 40n);
	return pointer;
}

function get_got(base_addr, value) {
	var got = new Array();
	var p_dyn, p_data, p_text;
	var e_phnum;
	var e_phoff;

	e_phnum = BigInt(arb_r2(base_addr + offsetof_e_phnum));
	e_phoff = BigInt(arb_r8(base_addr + offsetof_e_phoff));
	console.log("[+] Resolving symbols of ELF image @ 0x"+ base_addr.toString(16));	
	console.log("\t[+] e_phnum " + e_phnum);
	console.log("\t[+] e_phoff " + e_phoff);
	
	for (var i = 0n; i < e_phnum; i++) {
		var offset =  BigInt(e_phoff + sizeof_Elf64_Phdr * i);
		var p_type = BigInt(arb_r4(base_addr + offset + offsetof_p_type));
		var p_flags = BigInt(arb_r4(base_addr + offset + offsetof_p_flags));

		if (p_type == PT_LOAD && (p_flags & PF_X)) {
			p_text = i;
		} else if (p_type == PT_LOAD && (p_flags & PF_W)) {
			p_data = i;
		} else if (p_type == PT_DYNAMIC) {
			p_dyn = i;
		}
	}
	
	var p_dyn_filesz = BigInt(arb_r8(base_addr + e_phoff + sizeof_Elf64_Phdr * p_dyn + offsetof_p_filesz));
	var p_dyn_offset = BigInt(arb_r8(base_addr + e_phoff + sizeof_Elf64_Phdr * p_dyn + offsetof_p_offset));
	var p_dyn_vaddr = BigInt(arb_r8(base_addr + e_phoff + sizeof_Elf64_Phdr * p_dyn + offsetof_p_vaddr));
	var p_text_offset = BigInt(arb_r8(base_addr + e_phoff + sizeof_Elf64_Phdr * p_text + offsetof_p_offset));
	var p_text_vaddr = BigInt(arb_r8(base_addr + e_phoff + sizeof_Elf64_Phdr * p_text + offsetof_p_vaddr));
	var p_data_offset = BigInt(arb_r8(base_addr + e_phoff + sizeof_Elf64_Phdr * p_data + offsetof_p_offset));
	var p_data_vaddr = BigInt(arb_r8(base_addr + e_phoff + sizeof_Elf64_Phdr * p_data + offsetof_p_vaddr));
	
	console.log("\t[+] p_dyn_filesz " + p_dyn_filesz);
	console.log("\t[+] p_dyn_offset " + p_dyn_offset.toString(16));
	console.log("\t[+] p_text_offset " + p_text_offset);
	console.log("\t[+] p_text_vaddr " + p_text_vaddr);

	var jmprel, pltrelsz, relasz, strtab, symtab, relaent, strsz, pltgot, rel;

	for (var i = 0n; i < p_dyn_filesz/sizeof_Elf64_Dyn; i++) {
		var offset =  BigInt(p_dyn_vaddr + sizeof_Elf64_Dyn * i);
		var d_tag = BigInt(arb_r8(base_addr + offset + offsetof_d_tag));
		var d_val = BigInt(arb_r8(base_addr + offset + offsetof_d_un_d_val));

		switch (d_tag) {
		case DT_PLTGOT:
			pltgot = d_val;
			break;
		case DT_JMPREL:
			jmprel = d_val;
			break;
		case DT_PLTRELSZ:
			pltrelsz = d_val;
			break;
		case DT_SYMTAB:
			symtab = d_val;
			break;
		case DT_STRTAB:
			strtab = d_val;
			break;
		case DT_STRSZ:
			strsz = d_val;
			break;
		case DT_RELAENT:
			relaent = d_val;
			break;
		case DT_RELA:
			rel = d_val;
			break;
		case DT_RELASZ:
			relasz = d_val;
			break;
		default:
			break;
		}

	}
	/*
	console.log("pltgot: " + pltgot.toString(16));
	console.log("rel " + rel.toString(16));
	console.log("relsz " + relasz);
	console.log("symtab " + symtab.toString(16));
	console.log("strtab " + strtab.toString(16));
	console.log("strsz " + strsz);
	console.log("relaent " + relaent);
	console.log("rel entries: "+ relasz/relaent);
	*/

	var centinel;
	var size;
	if (value == R_X86_64_GLOB_DAT) {
		centinel = rel;
		size = relasz/relaent;
	} else {
		centinel = jmprel;
		size = pltrelsz/relaent;
	}
	
	for (var i = 0n; i < size; i++) {
		var offset =  BigInt(centinel + (sizeof_Elf64_Rela * i));
		var r_offset = BigInt(arb_r8(offset + offsetof_r_offset));
		var r_type = BigInt(arb_r4(offset + offsetof_r_info + 0n));
		var r_sym = BigInt(arb_r4(offset + offsetof_r_info + 4n));
		if (BigInt(r_type) == value) {
			var sym_offset =  BigInt(symtab + r_sym * sizeof_Elf64_Sym);
			if (sym_offset == 0n) {
				console.log("offset is zero");
				continue;
			}
			var st_name = BigInt(arb_r4(sym_offset + offsetof_st_name));
			if (st_name == 0n) {
				console.log("name is zero");
				continue;
			}
			var got_address;
			got_address = pltgot + (i+3n) * 8n;
			name = arb_rstring(strtab + st_name);
			console.log("\t\t["+i+"] "+r_type+" Symbol " + name + ":\t0x"+ got_address.toString(16));
			got[name] = got_address;
		}
	}
	return got;
}

